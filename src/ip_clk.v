// -----------------------------------------------------------------------------
// Portable clock generator with integer division
// -----------------------------------------------------------------------------
// This module emulates the behaviour of the original vendor PLL IP using only
// synthesizable Verilog. Two clock outputs are generated by dividing the input
// clock by configurable even integers. When the divide value is 1 the output
// simply follows the input clock. Odd divide values are rounded up to the next
// even number to maintain ~50% duty cycle.
//
// NOTE: This block can only divide the incoming clock; it cannot multiply the
//       frequency. Ensure that `clkin1` already meets the highest frequency
//       requirement of the design.
// -----------------------------------------------------------------------------
module ip_clk #(
    parameter integer CLKOUT0_DIVIDE = 1,  // Divide factor for clkout0
    parameter integer CLKOUT1_DIVIDE = 1,  // Divide factor for clkout1
    parameter integer LOCK_DELAY     = 32  // Cycles before pll_lock goes high
)(
    input  wire clkin1,
    output wire clkout0,
    output wire clkout1,
    output wire pll_lock
);

    // -------------------------------------------------------------------------
    // Helper function to force even divide factors >= 2. A divide of 1 is
    // treated separately (pass-through).
    // -------------------------------------------------------------------------
    function integer even_divide;
        input integer value;
        integer tmp;
        begin
            if (value <= 1) begin
                even_divide = 2;
            end else begin
                tmp = (value % 2) ? (value + 1) : value;
                even_divide = (tmp < 2) ? 2 : tmp;
            end
        end
    endfunction

    // -------------------------------------------------------------------------
    // clkout0 generation
    // -------------------------------------------------------------------------
    generate
        if (CLKOUT0_DIVIDE <= 1) begin : g_clk0_passthrough
            assign clkout0 = clkin1;
        end else begin : g_clk0_divider
            localparam integer DIV0 = even_divide(CLKOUT0_DIVIDE);
            localparam integer HALF0 = DIV0 / 2;
            reg [31:0] cnt0 = 32'd0;
            reg        clk0 = 1'b0;

            always @(posedge clkin1) begin
                if (cnt0 == DIV0 - 1) begin
                    cnt0 <= 32'd0;
                end else begin
                    cnt0 <= cnt0 + 32'd1;
                end

                if (cnt0 < HALF0)
                    clk0 <= 1'b1;
                else
                    clk0 <= 1'b0;
            end

            assign clkout0 = clk0;
        end
    endgenerate

    // -------------------------------------------------------------------------
    // clkout1 generation
    // -------------------------------------------------------------------------
    generate
        if (CLKOUT1_DIVIDE <= 1) begin : g_clk1_passthrough
            assign clkout1 = clkin1;
        end else begin : g_clk1_divider
            localparam integer DIV1 = even_divide(CLKOUT1_DIVIDE);
            localparam integer HALF1 = DIV1 / 2;
            reg [31:0] cnt1 = 32'd0;
            reg        clk1 = 1'b0;

            always @(posedge clkin1) begin
                if (cnt1 == DIV1 - 1) begin
                    cnt1 <= 32'd0;
                end else begin
                    cnt1 <= cnt1 + 32'd1;
                end

                if (cnt1 < HALF1)
                    clk1 <= 1'b1;
                else
                    clk1 <= 1'b0;
            end

            assign clkout1 = clk1;
        end
    endgenerate

    // -------------------------------------------------------------------------
    // Simple lock indicator: asserts after LOCK_DELAY cycles of the input clock
    // -------------------------------------------------------------------------
    localparam integer LOCK_MAX = (LOCK_DELAY < 1) ? 1 : LOCK_DELAY;

    reg [31:0] lock_cnt = 32'd0;
    reg        pll_lock_r = 1'b0;

    always @(posedge clkin1) begin
        if (!pll_lock_r) begin
            if (lock_cnt == LOCK_MAX - 1) begin
                pll_lock_r <= 1'b1;
            end else begin
                lock_cnt <= lock_cnt + 32'd1;
            end
        end
    end

    assign pll_lock = pll_lock_r;

endmodule
